'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var ReconnectingWebSocket = require('reconnecting-websocket');
var waitForExpect = require('wait-for-expect');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var ReconnectingWebSocket__default = /*#__PURE__*/_interopDefaultLegacy(ReconnectingWebSocket);
var waitForExpect__default = /*#__PURE__*/_interopDefaultLegacy(waitForExpect);

function _regeneratorRuntime() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

  _regeneratorRuntime = function () {
    return exports;
  };

  var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }

  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
    return generator._invoke = function (innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");

        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }

        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);

          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }

          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }(innerFn, self, context), generator;
  }

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  exports.wrap = wrap;
  var ContinueSentinel = {};

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {}

  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if ("throw" !== record.type) {
        var result = record.arg,
            value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }

      reject(record.arg);
    }

    var previousPromise;

    this._invoke = function (method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    };
  }

  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (undefined === method) {
      if (context.delegate = null, "throw" === context.method) {
        if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
        context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }

  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;

          return next.value = undefined, next.done = !0, next;
        };

        return next.next = next;
      }
    }

    return {
      next: doneResult
    };
  }

  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }

  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (object) {
    var keys = [];

    for (var key in object) keys.push(key);

    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }

      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;

      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
            record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      }

      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

var MessageTypes;

(function (MessageTypes) {
  MessageTypes["Hello"] = "hello";
  MessageTypes["Error"] = "error";
  MessageTypes["Subscribe"] = "subscribe";
  MessageTypes["SubscribeSucess"] = "subscribe_success";
  MessageTypes["Unsubscribe"] = "unsubscribe";
  MessageTypes["UnsubscribeSuccess"] = "unsubscribe_success";
  MessageTypes["Publish"] = "publish";
  MessageTypes["PublishSuccess"] = "publish_success";
})(MessageTypes || (MessageTypes = {}));

exports.AuthenticationType = void 0;

(function (AuthenticationType) {
  AuthenticationType[AuthenticationType["KEY"] = 0] = "KEY";
  AuthenticationType[AuthenticationType["TOKEN"] = 1] = "TOKEN";
})(exports.AuthenticationType || (exports.AuthenticationType = {}));

var defaults = {
  baseURL: 'wss://mycelium-server.fly.dev/realtime'
};

var Client = /*#__PURE__*/function () {
  function Client(connection) {
    this.channels = new Map();
    this.seqNumber = 1;
    this.acks = new Map();
    this.specialEventsHandlers = new Map();
    this.ws = void 0;
    this.sid = void 0;
    this.isConnected = false;

    if (!connection.manual) {
      this.connect(connection);
    }
  }

  var _proto = Client.prototype;

  _proto.getChannels = function getChannels() {
    return Array.from(this.channels.keys());
  };

  _proto.channel = /*#__PURE__*/function () {
    var _channel = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(channelName) {
      var _this = this;

      var existingChannel, subscribeSeq, ack, channel;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!(!this.isConnected || !this.ws)) {
                _context3.next = 2;
                break;
              }

              throw new Error("failed to use channel " + channelName + ", not connected");

            case 2:
              existingChannel = this.channels.get(channelName);

              if (!existingChannel) {
                _context3.next = 5;
                break;
              }

              return _context3.abrupt("return", existingChannel.instance);

            case 5:
              subscribeSeq = this.seqNumber++;
              this.ws.send(JSON.stringify({
                t: MessageTypes.Subscribe,
                d: {
                  s: subscribeSeq,
                  c: channelName
                }
              }));
              _context3.next = 9;
              return waitForExpect__default["default"](function () {
                if (!_this.acks.has(subscribeSeq)) {
                  throw new Error("failed to subscribe to channel " + channelName + ", timed out");
                }
              });

            case 9:
              ack = this.acks.get(subscribeSeq);

              if (!(ack != null && ack.failureReason)) {
                _context3.next = 12;
                break;
              }

              throw new Error(ack.failureReason);

            case 12:
              channel = {
                name: channelName,
                unsubscribe: function () {
                  var _unsubscribe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
                    var unsubscribeSeq, ack;
                    return _regeneratorRuntime().wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            if (!(!_this.isConnected || !_this.ws)) {
                              _context.next = 2;
                              break;
                            }

                            throw new Error("failed to unsubscribe from channel " + channelName + ", not connected");

                          case 2:
                            if (_this.channels.has(channelName)) {
                              _context.next = 4;
                              break;
                            }

                            throw new Error("failed to unsubscribe from channel " + channelName + ", not subscribed");

                          case 4:
                            unsubscribeSeq = _this.seqNumber++;

                            _this.ws.send(JSON.stringify({
                              t: MessageTypes.Unsubscribe,
                              d: {
                                s: unsubscribeSeq,
                                c: channelName
                              }
                            }));

                            _context.next = 8;
                            return waitForExpect__default["default"](function () {
                              if (!_this.acks.has(unsubscribeSeq)) {
                                throw new Error("failed to unsubscribe from channel " + channelName + ", timed out");
                              }
                            });

                          case 8:
                            ack = _this.acks.get(unsubscribeSeq);

                            if (!(ack != null && ack.failureReason)) {
                              _context.next = 11;
                              break;
                            }

                            throw new Error(ack.failureReason);

                          case 11:
                            _this.channels["delete"](channelName);

                          case 12:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }));

                  function unsubscribe() {
                    return _unsubscribe.apply(this, arguments);
                  }

                  return unsubscribe;
                }(),
                off: function off(event, listener) {
                  var channel = _this.channels.get(channelName);

                  if (channel) {
                    _this.channels.set(channelName, _extends({}, channel, {
                      eventListeners: channel.eventListeners.filter(function (l) {
                        return l.event !== event && l.listener !== listener;
                      })
                    }));
                  }
                },
                offOnce: function offOnce(event, listener) {
                  var channel = _this.channels.get(channelName);

                  if (channel) {
                    _this.channels.set(channelName, _extends({}, channel, {
                      onceListeners: channel.onceListeners.filter(function (l) {
                        return l.event !== event && l.listener !== listener;
                      })
                    }));
                  }
                },
                offAny: function offAny() {
                  for (var _len = arguments.length, listeners = new Array(_len), _key = 0; _key < _len; _key++) {
                    listeners[_key] = arguments[_key];
                  }

                  var channel = _this.channels.get(channelName);

                  if (channel) {
                    if (!listeners.length) {
                      // Remove all listeners
                      _this.channels.set(channelName, _extends({}, channel, {
                        anyListeners: []
                      }));

                      return;
                    }

                    _this.channels.set(channelName, _extends({}, channel, {
                      anyListeners: channel.anyListeners.filter(function (l) {
                        return !listeners.some(function (listener) {
                          return listener === l;
                        });
                      })
                    }));
                  }
                },
                on: function on(event, _listener) {
                  var channel = _this.channels.get(channelName);

                  if (channel) {
                    _this.channels.set(channelName, _extends({}, channel, {
                      eventListeners: [].concat(channel.eventListeners, [{
                        event: event,
                        listener: function listener(data, event) {
                          _listener(data, event);
                        }
                      }])
                    }));
                  }
                },
                onAny: function onAny(listener) {
                  var channel = _this.channels.get(channelName);

                  if (channel) {
                    _this.channels.set(channelName, _extends({}, channel, {
                      anyListeners: [].concat(channel.anyListeners, [listener])
                    }));
                  }
                },
                once: function once(event, _listener2) {
                  var channel = _this.channels.get(channelName);

                  if (channel) {
                    _this.channels.set(channelName, _extends({}, channel, {
                      onceListeners: [].concat(channel.onceListeners.filter(function (l) {
                        return l.event !== event;
                      }), [{
                        event: event,
                        listener: function listener(data, event) {
                          _listener2(data, event);
                        }
                      }])
                    }));
                  }
                },
                prependAny: function prependAny(listener) {
                  var channel = _this.channels.get(channelName);

                  if (channel) {
                    _this.channels.set(channelName, _extends({}, channel, {
                      anyListeners: [listener].concat(channel.anyListeners)
                    }));
                  }
                },
                removeAllListeners: function removeAllListeners() {
                  for (var _len2 = arguments.length, events = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                    events[_key2] = arguments[_key2];
                  }

                  var channel = _this.channels.get(channelName);

                  if (channel) {
                    if (!events.length) {
                      // Remove all listeners
                      _this.channels.set(channelName, _extends({}, channel, {
                        eventListeners: []
                      }));

                      return;
                    }

                    _this.channels.set(channelName, _extends({}, channel, {
                      eventListeners: channel.eventListeners.filter(function (l) {
                        return !events.some(function (ev) {
                          return ev === l.event;
                        });
                      })
                    }));
                  }
                },
                publish: function () {
                  var _publish = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(event, data, includePublisher) {
                    var publishSeq, ack;
                    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            if (includePublisher === void 0) {
                              includePublisher = false;
                            }

                            if (!(!_this.isConnected || !_this.ws)) {
                              _context2.next = 3;
                              break;
                            }

                            throw new Error("failed to publish message on channel " + channelName + ", not connected");

                          case 3:
                            publishSeq = _this.seqNumber++;

                            _this.ws.send(JSON.stringify({
                              t: MessageTypes.Publish,
                              d: {
                                e: event,
                                s: publishSeq,
                                c: channelName,
                                d: data,
                                ip: includePublisher
                              }
                            }));

                            _context2.next = 7;
                            return waitForExpect__default["default"](function () {
                              if (!_this.acks.has(publishSeq)) {
                                throw new Error("failed to publish message on channel " + channelName + ", timed out");
                              }
                            });

                          case 7:
                            ack = _this.acks.get(publishSeq);

                            if (!(ack != null && ack.failureReason)) {
                              _context2.next = 10;
                              break;
                            }

                            throw new Error(ack.failureReason);

                          case 10:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }));

                  function publish(_x2, _x3, _x4) {
                    return _publish.apply(this, arguments);
                  }

                  return publish;
                }()
              };
              this.channels.set(channelName, {
                instance: channel,
                anyListeners: [],
                eventListeners: [],
                onceListeners: []
              });
              return _context3.abrupt("return", channel);

            case 15:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function channel(_x) {
      return _channel.apply(this, arguments);
    }

    return channel;
  }();

  _proto.on = function on(specialEvent, handler) {
    var existingHandlers = this.specialEventsHandlers.get(specialEvent) || [];
    this.specialEventsHandlers.set(specialEvent, [].concat(existingHandlers, [handler]));
  };

  _proto.runSpecialEventHandlers = function runSpecialEventHandlers(specialEvent) {
    var _this$specialEventsHa;

    (_this$specialEventsHa = this.specialEventsHandlers.get(specialEvent)) == null ? void 0 : _this$specialEventsHa.forEach(function (handler) {
      handler();
    });
  };

  _proto.disconnect = function disconnect() {
    if (!this.ws || !this.isConnected) {
      throw new Error("can't disconnect, not connected");
    }

    this.ws.close(); // Reset state.

    this.acks = new Map();
    this.channels = new Map();
    this.seqNumber = 1;
    this.isConnected = false;
    this.sid = undefined;
    this.ws = undefined;
  };

  _proto.connect = /*#__PURE__*/function () {
    var _connect = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref) {
      var authentication, _ref$baseURL, baseURL, url, key, token;

      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              authentication = _ref.authentication, _ref$baseURL = _ref.baseURL, baseURL = _ref$baseURL === void 0 ? defaults.baseURL : _ref$baseURL;

              if (!(authentication.type === exports.AuthenticationType.KEY)) {
                _context4.next = 8;
                break;
              }

              _context4.next = 4;
              return authentication.getKey();

            case 4:
              key = _context4.sent;
              url = baseURL + "?key=" + key;
              _context4.next = 12;
              break;

            case 8:
              _context4.next = 10;
              return authentication.getToken();

            case 10:
              token = _context4.sent;
              url = baseURL + "?token=" + token;

            case 12:
              this.ws = new ReconnectingWebSocket__default["default"](url);
              this.setupListeners();

            case 14:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function connect(_x5) {
      return _connect.apply(this, arguments);
    }

    return connect;
  }();

  _proto.setupListeners = function setupListeners() {
    var _this2 = this;

    if (!this.ws) {
      return;
    }

    this.ws.addEventListener('error', function () {
      _this2.runSpecialEventHandlers('disconnect');
    });
    this.ws.addEventListener('close', function () {
      _this2.runSpecialEventHandlers('disconnect');
    });
    this.ws.addEventListener('message', function (ev) {
      try {
        var message = JSON.parse(ev.data.toString());

        switch (message.t) {
          case MessageTypes.Hello:
            {
              var sid = message.d.sid;
              _this2.sid = sid;
              _this2.isConnected = true;

              _this2.runSpecialEventHandlers('connect');

              return;
            }

          case MessageTypes.Publish:
            {
              var _message$d = message.d,
                  channelName = _message$d.c,
                  data = _message$d.d,
                  event = _message$d.e;

              var channel = _this2.channels.get(channelName);

              if (channel) {
                var _channel$onceListener;

                channel.eventListeners.forEach(function (l) {
                  if (l.event === event) {
                    l.listener(data, event);
                  }
                });
                (_channel$onceListener = channel.onceListeners.find(function (l) {
                  return l.event === event;
                })) == null ? void 0 : _channel$onceListener.listener(data, event);
                channel.anyListeners.forEach(function (listener) {
                  listener(data, event);
                });
              }

              return;
            }

          case MessageTypes.UnsubscribeSuccess:
          case MessageTypes.PublishSuccess:
          case MessageTypes.SubscribeSucess:
            {
              var _message$d2 = message.d,
                  _channelName = _message$d2.c,
                  s = _message$d2.s;

              _this2.acks.set(s, {});

              return;
            }

          case MessageTypes.Error:
            {
              var reason = message.r,
                  _s = message.s;

              if (_s) {
                _this2.acks.set(_s, {
                  failureReason: reason
                });
              }

              return;
            }
        }
      } catch (error) {
        console.error(error);
      }
    });
  };

  return Client;
}();

exports.Client = Client;
//# sourceMappingURL=core.cjs.development.js.map
