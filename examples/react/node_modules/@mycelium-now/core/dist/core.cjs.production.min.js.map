{"version":3,"file":"core.cjs.production.min.js","sources":["../src/message.ts","../src/client.ts"],"sourcesContent":["enum MessageTypes {\n  Hello = 'hello',\n  Error = 'error',\n  Subscribe = 'subscribe',\n  SubscribeSucess = 'subscribe_success',\n  Unsubscribe = 'unsubscribe',\n  UnsubscribeSuccess = 'unsubscribe_success',\n  Publish = 'publish',\n  PublishSuccess = 'publish_success',\n}\n\ninterface HelloMessage {\n  t: MessageTypes.Hello;\n  d: {\n    sid: string;\n  };\n}\n\ninterface SubscribeSuccessMessage {\n  t: MessageTypes.SubscribeSucess;\n  d: {\n    s: number;\n    c: string;\n  };\n}\n\ninterface PublishSuccessMessage {\n  t: MessageTypes.PublishSuccess;\n  d: {\n    s: number;\n    c: string;\n  };\n}\n\ninterface PublishMessage {\n  t: MessageTypes.Publish;\n  d: {\n    e: string;\n    c: string;\n    d: unknown;\n  };\n}\n\ninterface ErrorMessage {\n  s?: number;\n  t: MessageTypes;\n  r: string;\n}\n\nexport {\n  ErrorMessage,\n  HelloMessage,\n  MessageTypes,\n  PublishMessage,\n  PublishSuccessMessage,\n  SubscribeSuccessMessage,\n};\n","import ReconnectingWebSocket from 'reconnecting-websocket';\nimport waitForExpect from 'wait-for-expect';\n\nimport {\n  ErrorMessage,\n  HelloMessage,\n  MessageTypes,\n  PublishMessage,\n  PublishSuccessMessage,\n  SubscribeSuccessMessage,\n} from './message';\n\ninterface KeyAuthentication {\n  type: AuthenticationType.KEY;\n\n  /**\n   * How to get the key used to authenticate the connection. For example by simply returning it or fetching it.\n   * Don't use this authentication type in untrusted environments.\n   * ```js\n   * return \"my-key-id:my-key-secret\";\n   * ```\n   */\n  getKey: () => string | Promise<string>;\n}\n\ninterface TokenAuthentication {\n  type: AuthenticationType.TOKEN;\n\n  /**\n   * How to get the token used to authenticate the connection. For example by fetching your API which\n   * returns the token.\n   * ```js\n   * const { token } = await fetch(MY_API_URL).then(r => r.json());\n   * return token;\n   * ```\n   */\n  getToken: () => string | Promise<string>;\n}\n\nenum AuthenticationType {\n  KEY,\n  TOKEN,\n}\n\ninterface Connection {\n  authentication: KeyAuthentication | TokenAuthentication;\n  baseURL?: string;\n  manual?: boolean;\n}\n\ninterface Ack {\n  failureReason?: string;\n}\n\ntype SpecialEvent = 'connect' | 'disconnect';\n\ntype Listener<TData> = (data: TData, event: string) => void;\n\ninterface Channel {\n  name: string;\n  on: <TData = unknown>(event: string, listener: Listener<TData>) => void;\n  once: <TData = unknown>(event: string, listener: Listener<TData>) => void;\n  off: <TData>(event: string, listener: Listener<TData>) => void;\n  offOnce: <TData>(event: string, listener: Listener<TData>) => void;\n  removeAllListeners: (...events: string[]) => void;\n  onAny: <TData>(listener: Listener<TData>) => void;\n  prependAny: <TData>(listener: Listener<TData>) => void;\n  offAny: <TData>(...listeners: Listener<TData>[]) => void;\n  publish: <TData = unknown>(\n    event: string,\n    data: TData,\n    includePublisher: boolean\n  ) => Promise<void>;\n  unsubscribe: () => Promise<void>;\n}\n\nconst defaults = {\n  baseURL: 'wss://mycelium-server.fly.dev/realtime',\n};\n\nclass Client {\n  private channels = new Map<\n    string,\n    {\n      instance: Channel;\n      eventListeners: { event: string; listener: Listener<any> }[];\n      anyListeners: Listener<any>[];\n      onceListeners: { event: string; listener: Listener<any> }[];\n    }\n  >();\n\n  private seqNumber = 1;\n  private acks = new Map<number, Ack>();\n  private specialEventsHandlers = new Map<SpecialEvent, VoidFunction[]>();\n  private ws: ReconnectingWebSocket | undefined;\n\n  public sid: string | undefined;\n  public isConnected = false;\n\n  constructor(connection: Connection) {\n    if (!connection.manual) {\n      this.connect(connection);\n    }\n  }\n\n  public getChannels() {\n    return Array.from(this.channels.keys());\n  }\n\n  public async channel(channelName: string): Promise<Channel> {\n    if (!this.isConnected || !this.ws) {\n      throw new Error(`failed to use channel ${channelName}, not connected`);\n    }\n\n    const existingChannel = this.channels.get(channelName);\n    if (existingChannel) {\n      return existingChannel.instance;\n    }\n\n    const subscribeSeq = this.seqNumber++;\n\n    this.ws.send(\n      JSON.stringify({\n        t: MessageTypes.Subscribe,\n        d: {\n          s: subscribeSeq,\n          c: channelName,\n        },\n      })\n    );\n\n    await waitForExpect(() => {\n      if (!this.acks.has(subscribeSeq)) {\n        throw new Error(\n          `failed to subscribe to channel ${channelName}, timed out`\n        );\n      }\n    });\n\n    const ack = this.acks.get(subscribeSeq);\n    if (ack?.failureReason) {\n      throw new Error(ack.failureReason);\n    }\n\n    const channel: Channel = {\n      name: channelName,\n\n      unsubscribe: async () => {\n        if (!this.isConnected || !this.ws) {\n          throw new Error(\n            `failed to unsubscribe from channel ${channelName}, not connected`\n          );\n        }\n\n        if (!this.channels.has(channelName)) {\n          throw new Error(\n            `failed to unsubscribe from channel ${channelName}, not subscribed`\n          );\n        }\n\n        const unsubscribeSeq = this.seqNumber++;\n\n        this.ws.send(\n          JSON.stringify({\n            t: MessageTypes.Unsubscribe,\n            d: {\n              s: unsubscribeSeq,\n              c: channelName,\n            },\n          })\n        );\n\n        await waitForExpect(() => {\n          if (!this.acks.has(unsubscribeSeq)) {\n            throw new Error(\n              `failed to unsubscribe from channel ${channelName}, timed out`\n            );\n          }\n        });\n\n        const ack = this.acks.get(unsubscribeSeq);\n        if (ack?.failureReason) {\n          throw new Error(ack.failureReason);\n        }\n\n        this.channels.delete(channelName);\n      },\n\n      off: (event, listener) => {\n        const channel = this.channels.get(channelName);\n        if (channel) {\n          this.channels.set(channelName, {\n            ...channel,\n            eventListeners: channel.eventListeners.filter(\n              (l) => l.event !== event && l.listener !== listener\n            ),\n          });\n        }\n      },\n\n      offOnce: (event, listener) => {\n        const channel = this.channels.get(channelName);\n        if (channel) {\n          this.channels.set(channelName, {\n            ...channel,\n            onceListeners: channel.onceListeners.filter(\n              (l) => l.event !== event && l.listener !== listener\n            ),\n          });\n        }\n      },\n\n      offAny: (...listeners) => {\n        const channel = this.channels.get(channelName);\n        if (channel) {\n          if (!listeners.length) {\n            // Remove all listeners\n            this.channels.set(channelName, {\n              ...channel,\n              anyListeners: [],\n            });\n\n            return;\n          }\n\n          this.channels.set(channelName, {\n            ...channel,\n            anyListeners: channel.anyListeners.filter(\n              (l) => !listeners.some((listener) => listener === l)\n            ),\n          });\n        }\n      },\n\n      on: (event, listener) => {\n        const channel = this.channels.get(channelName);\n        if (channel) {\n          this.channels.set(channelName, {\n            ...channel,\n            eventListeners: [\n              ...channel.eventListeners,\n              {\n                event,\n                listener: (data: any, event) => {\n                  listener(data, event);\n                },\n              },\n            ],\n          });\n        }\n      },\n\n      onAny: (listener) => {\n        const channel = this.channels.get(channelName);\n        if (channel) {\n          this.channels.set(channelName, {\n            ...channel,\n            anyListeners: [...channel.anyListeners, listener],\n          });\n        }\n      },\n\n      once: (event, listener) => {\n        const channel = this.channels.get(channelName);\n        if (channel) {\n          this.channels.set(channelName, {\n            ...channel,\n            onceListeners: [\n              ...channel.onceListeners.filter((l) => l.event !== event),\n              {\n                event,\n                listener: (data: any, event) => {\n                  listener(data, event);\n                },\n              },\n            ],\n          });\n        }\n      },\n\n      prependAny: (listener) => {\n        const channel = this.channels.get(channelName);\n        if (channel) {\n          this.channels.set(channelName, {\n            ...channel,\n            anyListeners: [listener, ...channel.anyListeners],\n          });\n        }\n      },\n\n      removeAllListeners: (...events) => {\n        const channel = this.channels.get(channelName);\n        if (channel) {\n          if (!events.length) {\n            // Remove all listeners\n            this.channels.set(channelName, {\n              ...channel,\n              eventListeners: [],\n            });\n\n            return;\n          }\n\n          this.channels.set(channelName, {\n            ...channel,\n            eventListeners: channel.eventListeners.filter(\n              (l) => !events.some((ev) => ev === l.event)\n            ),\n          });\n        }\n      },\n\n      publish: async (event, data, includePublisher = false) => {\n        if (!this.isConnected || !this.ws) {\n          throw new Error(\n            `failed to publish message on channel ${channelName}, not connected`\n          );\n        }\n\n        const publishSeq = this.seqNumber++;\n\n        this.ws.send(\n          JSON.stringify({\n            t: MessageTypes.Publish,\n            d: {\n              e: event,\n              s: publishSeq,\n              c: channelName,\n              d: data,\n              ip: includePublisher,\n            },\n          })\n        );\n\n        await waitForExpect(() => {\n          if (!this.acks.has(publishSeq)) {\n            throw new Error(\n              `failed to publish message on channel ${channelName}, timed out`\n            );\n          }\n        });\n\n        const ack = this.acks.get(publishSeq);\n        if (ack?.failureReason) {\n          throw new Error(ack.failureReason);\n        }\n      },\n    };\n\n    this.channels.set(channelName, {\n      instance: channel,\n      anyListeners: [],\n      eventListeners: [],\n      onceListeners: [],\n    });\n\n    return channel;\n  }\n\n  public on(specialEvent: SpecialEvent, handler: VoidFunction) {\n    const existingHandlers = this.specialEventsHandlers.get(specialEvent) || [];\n    this.specialEventsHandlers.set(specialEvent, [\n      ...existingHandlers,\n      handler,\n    ]);\n  }\n\n  private runSpecialEventHandlers(specialEvent: SpecialEvent) {\n    this.specialEventsHandlers.get(specialEvent)?.forEach((handler) => {\n      handler();\n    });\n  }\n\n  public disconnect() {\n    if (!this.ws || !this.isConnected) {\n      throw new Error(`can't disconnect, not connected`);\n    }\n\n    this.ws.close();\n\n    // Reset state.\n    this.acks = new Map();\n    this.channels = new Map();\n    this.seqNumber = 1;\n    this.isConnected = false;\n    this.sid = undefined;\n    this.ws = undefined;\n  }\n\n  public async connect({\n    authentication,\n    baseURL = defaults.baseURL,\n  }: Connection) {\n    let url: string;\n    if (authentication.type === AuthenticationType.KEY) {\n      const key = await authentication.getKey();\n      url = `${baseURL}?key=${key}`;\n    } else {\n      const token = await authentication.getToken();\n      url = `${baseURL}?token=${token}`;\n    }\n\n    this.ws = new ReconnectingWebSocket(url);\n    this.setupListeners();\n  }\n\n  private setupListeners() {\n    if (!this.ws) {\n      return;\n    }\n\n    this.ws.addEventListener('error', () => {\n      this.runSpecialEventHandlers('disconnect');\n    });\n\n    this.ws.addEventListener('close', () => {\n      this.runSpecialEventHandlers('disconnect');\n    });\n\n    this.ws.addEventListener('message', (ev) => {\n      try {\n        const message = JSON.parse(ev.data.toString());\n        switch (message.t) {\n          case MessageTypes.Hello: {\n            const { sid } = message.d as HelloMessage['d'];\n            this.sid = sid;\n            this.isConnected = true;\n            this.runSpecialEventHandlers('connect');\n            return;\n          }\n\n          case MessageTypes.Publish: {\n            const {\n              c: channelName,\n              d: data,\n              e: event,\n            } = message.d as PublishMessage['d'];\n\n            const channel = this.channels.get(channelName);\n            if (channel) {\n              channel.eventListeners.forEach((l) => {\n                if (l.event === event) {\n                  l.listener(data, event);\n                }\n              });\n\n              channel.onceListeners\n                .find((l) => l.event === event)\n                ?.listener(data, event);\n\n              channel.anyListeners.forEach((listener) => {\n                listener(data, event);\n              });\n            }\n\n            return;\n          }\n\n          case MessageTypes.UnsubscribeSuccess:\n          case MessageTypes.PublishSuccess:\n          case MessageTypes.SubscribeSucess: {\n            const { c: channelName, s } =\n              message.d as SubscribeSuccessMessage['d'];\n\n            this.acks.set(s, {});\n            return;\n          }\n\n          case MessageTypes.Error: {\n            const { r: reason, s } = message as ErrorMessage;\n            if (s) {\n              this.acks.set(s, { failureReason: reason });\n            }\n\n            return;\n          }\n        }\n      } catch (error) {\n        console.error(error);\n      }\n    });\n  }\n}\n\nexport {\n  Client,\n  AuthenticationType,\n  Connection,\n  TokenAuthentication,\n  KeyAuthentication,\n  Channel,\n};\n\nexport type { Listener };\n"],"names":["MessageTypes","AuthenticationType","Client","connection","this","channels","Map","seqNumber","acks","specialEventsHandlers","ws","sid","isConnected","manual","connect","getChannels","Array","from","keys","channel","_channel","_asyncToGenerator","_regeneratorRuntime","mark","_callee3","channelName","existingChannel","subscribeSeq","ack","_this","wrap","_context3","prev","next","Error","get","instance","send","JSON","stringify","t","Subscribe","d","s","c","waitForExpect","has","failureReason","name","unsubscribe","_unsubscribe","_callee","unsubscribeSeq","_context","Unsubscribe","stop","apply","arguments","off","event","listener","set","eventListeners","filter","l","offOnce","onceListeners","offAny","_len","length","listeners","_key","anyListeners","some","on","data","onAny","once","concat","prependAny","removeAllListeners","_len2","events","_key2","ev","publish","_publish","includePublisher","publishSeq","_context2","Publish","e","ip","_callee2","_x2","_x3","_x4","abrupt","specialEvent","handler","existingHandlers","runSpecialEventHandlers","_this$specialEventsHa","forEach","disconnect","close","undefined","_connect","_callee4","_ref","authentication","_ref$baseURL","baseURL","url","_context4","type","KEY","getKey","sent","getToken","ReconnectingWebSocket","setupListeners","_this2","addEventListener","message","parse","toString","Hello","_channel$onceListener","find","UnsubscribeSuccess","PublishSuccess","SubscribeSucess","r","error","console"],"mappings":"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"}