import {
  __commonJS,
  __toESM,
  require_react
} from "./chunk-TWAPIMRI.js";

// node_modules/invariant/browser.js
var require_browser = __commonJS({
  "node_modules/invariant/browser.js"(exports, module) {
    "use strict";
    var invariant2 = function(condition, format, a, b, c, d, e, f) {
      if (true) {
        if (format === void 0) {
          throw new Error("invariant requires an error message argument");
        }
      }
      if (!condition) {
        var error;
        if (format === void 0) {
          error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error(format.replace(/%s/g, function() {
            return args[argIndex++];
          }));
          error.name = "Invariant Violation";
        }
        error.framesToPop = 1;
        throw error;
      }
    };
    module.exports = invariant2;
  }
});

// node_modules/wait-for-expect/lib/helpers.js
var require_helpers = __commonJS({
  "node_modules/wait-for-expect/lib/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getSetTimeoutFn = getSetTimeoutFn;
    var globalObj = typeof window === "undefined" ? global : window;
    function runWithRealTimers(callback) {
      var usingJestFakeTimers = globalObj.setTimeout._isMockFunction && typeof jest !== "undefined";
      if (usingJestFakeTimers) {
        jest.useRealTimers();
      }
      var callbackReturnValue = callback();
      if (usingJestFakeTimers) {
        jest.useFakeTimers();
      }
      return callbackReturnValue;
    }
    function getSetTimeoutFn() {
      return runWithRealTimers(function() {
        return globalObj.setTimeout;
      });
    }
  }
});

// node_modules/wait-for-expect/lib/index.js
var require_lib = __commonJS({
  "node_modules/wait-for-expect/lib/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _helpers = require_helpers();
    var defaults2 = {
      timeout: 4500,
      interval: 50
    };
    var waitForExpect2 = function waitForExpect3(expectation) {
      var timeout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaults2.timeout;
      var interval = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaults2.interval;
      var setTimeout2 = (0, _helpers.getSetTimeoutFn)();
      if (interval < 1)
        interval = 1;
      var maxTries = Math.ceil(timeout / interval);
      var tries = 0;
      return new Promise(function(resolve, reject) {
        var rejectOrRerun = function rejectOrRerun2(error) {
          if (tries > maxTries) {
            reject(error);
            return;
          }
          setTimeout2(runExpectation, interval);
        };
        function runExpectation() {
          tries += 1;
          try {
            Promise.resolve(expectation()).then(function() {
              return resolve();
            }).catch(rejectOrRerun);
          } catch (error) {
            rejectOrRerun(error);
          }
        }
        setTimeout2(runExpectation, 0);
      });
    };
    waitForExpect2.defaults = defaults2;
    var _default = waitForExpect2;
    exports.default = _default;
    module.exports = exports.default;
    module.exports.default = exports.default;
  }
});

// node_modules/@mycelium-now/react/dist/react.esm.js
var import_react = __toESM(require_react());
var import_invariant = __toESM(require_browser());

// node_modules/reconnecting-websocket/dist/reconnecting-websocket-mjs.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (b2.hasOwnProperty(p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __values(o) {
  var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
  if (m)
    return m.call(o);
  return {
    next: function() {
      if (o && i >= o.length)
        o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
var Event = function() {
  function Event2(type, target) {
    this.target = target;
    this.type = type;
  }
  return Event2;
}();
var ErrorEvent = function(_super) {
  __extends(ErrorEvent2, _super);
  function ErrorEvent2(error, target) {
    var _this = _super.call(this, "error", target) || this;
    _this.message = error.message;
    _this.error = error;
    return _this;
  }
  return ErrorEvent2;
}(Event);
var CloseEvent = function(_super) {
  __extends(CloseEvent2, _super);
  function CloseEvent2(code, reason, target) {
    if (code === void 0) {
      code = 1e3;
    }
    if (reason === void 0) {
      reason = "";
    }
    var _this = _super.call(this, "close", target) || this;
    _this.wasClean = true;
    _this.code = code;
    _this.reason = reason;
    return _this;
  }
  return CloseEvent2;
}(Event);
var getGlobalWebSocket = function() {
  if (typeof WebSocket !== "undefined") {
    return WebSocket;
  }
};
var isWebSocket = function(w) {
  return typeof w !== "undefined" && !!w && w.CLOSING === 2;
};
var DEFAULT = {
  maxReconnectionDelay: 1e4,
  minReconnectionDelay: 1e3 + Math.random() * 4e3,
  minUptime: 5e3,
  reconnectionDelayGrowFactor: 1.3,
  connectionTimeout: 4e3,
  maxRetries: Infinity,
  maxEnqueuedMessages: Infinity,
  startClosed: false,
  debug: false
};
var ReconnectingWebSocket = function() {
  function ReconnectingWebSocket2(url, protocols, options) {
    var _this = this;
    if (options === void 0) {
      options = {};
    }
    this._listeners = {
      error: [],
      message: [],
      open: [],
      close: []
    };
    this._retryCount = -1;
    this._shouldReconnect = true;
    this._connectLock = false;
    this._binaryType = "blob";
    this._closeCalled = false;
    this._messageQueue = [];
    this.onclose = null;
    this.onerror = null;
    this.onmessage = null;
    this.onopen = null;
    this._handleOpen = function(event) {
      _this._debug("open event");
      var _a = _this._options.minUptime, minUptime = _a === void 0 ? DEFAULT.minUptime : _a;
      clearTimeout(_this._connectTimeout);
      _this._uptimeTimeout = setTimeout(function() {
        return _this._acceptOpen();
      }, minUptime);
      _this._ws.binaryType = _this._binaryType;
      _this._messageQueue.forEach(function(message) {
        return _this._ws.send(message);
      });
      _this._messageQueue = [];
      if (_this.onopen) {
        _this.onopen(event);
      }
      _this._listeners.open.forEach(function(listener) {
        return _this._callEventListener(event, listener);
      });
    };
    this._handleMessage = function(event) {
      _this._debug("message event");
      if (_this.onmessage) {
        _this.onmessage(event);
      }
      _this._listeners.message.forEach(function(listener) {
        return _this._callEventListener(event, listener);
      });
    };
    this._handleError = function(event) {
      _this._debug("error event", event.message);
      _this._disconnect(void 0, event.message === "TIMEOUT" ? "timeout" : void 0);
      if (_this.onerror) {
        _this.onerror(event);
      }
      _this._debug("exec error listeners");
      _this._listeners.error.forEach(function(listener) {
        return _this._callEventListener(event, listener);
      });
      _this._connect();
    };
    this._handleClose = function(event) {
      _this._debug("close event");
      _this._clearTimeouts();
      if (_this._shouldReconnect) {
        _this._connect();
      }
      if (_this.onclose) {
        _this.onclose(event);
      }
      _this._listeners.close.forEach(function(listener) {
        return _this._callEventListener(event, listener);
      });
    };
    this._url = url;
    this._protocols = protocols;
    this._options = options;
    if (this._options.startClosed) {
      this._shouldReconnect = false;
    }
    this._connect();
  }
  Object.defineProperty(ReconnectingWebSocket2, "CONNECTING", {
    get: function() {
      return 0;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ReconnectingWebSocket2, "OPEN", {
    get: function() {
      return 1;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ReconnectingWebSocket2, "CLOSING", {
    get: function() {
      return 2;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ReconnectingWebSocket2, "CLOSED", {
    get: function() {
      return 3;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ReconnectingWebSocket2.prototype, "CONNECTING", {
    get: function() {
      return ReconnectingWebSocket2.CONNECTING;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ReconnectingWebSocket2.prototype, "OPEN", {
    get: function() {
      return ReconnectingWebSocket2.OPEN;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ReconnectingWebSocket2.prototype, "CLOSING", {
    get: function() {
      return ReconnectingWebSocket2.CLOSING;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ReconnectingWebSocket2.prototype, "CLOSED", {
    get: function() {
      return ReconnectingWebSocket2.CLOSED;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ReconnectingWebSocket2.prototype, "binaryType", {
    get: function() {
      return this._ws ? this._ws.binaryType : this._binaryType;
    },
    set: function(value) {
      this._binaryType = value;
      if (this._ws) {
        this._ws.binaryType = value;
      }
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ReconnectingWebSocket2.prototype, "retryCount", {
    get: function() {
      return Math.max(this._retryCount, 0);
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ReconnectingWebSocket2.prototype, "bufferedAmount", {
    get: function() {
      var bytes = this._messageQueue.reduce(function(acc, message) {
        if (typeof message === "string") {
          acc += message.length;
        } else if (message instanceof Blob) {
          acc += message.size;
        } else {
          acc += message.byteLength;
        }
        return acc;
      }, 0);
      return bytes + (this._ws ? this._ws.bufferedAmount : 0);
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ReconnectingWebSocket2.prototype, "extensions", {
    get: function() {
      return this._ws ? this._ws.extensions : "";
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ReconnectingWebSocket2.prototype, "protocol", {
    get: function() {
      return this._ws ? this._ws.protocol : "";
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ReconnectingWebSocket2.prototype, "readyState", {
    get: function() {
      if (this._ws) {
        return this._ws.readyState;
      }
      return this._options.startClosed ? ReconnectingWebSocket2.CLOSED : ReconnectingWebSocket2.CONNECTING;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ReconnectingWebSocket2.prototype, "url", {
    get: function() {
      return this._ws ? this._ws.url : "";
    },
    enumerable: true,
    configurable: true
  });
  ReconnectingWebSocket2.prototype.close = function(code, reason) {
    if (code === void 0) {
      code = 1e3;
    }
    this._closeCalled = true;
    this._shouldReconnect = false;
    this._clearTimeouts();
    if (!this._ws) {
      this._debug("close enqueued: no ws instance");
      return;
    }
    if (this._ws.readyState === this.CLOSED) {
      this._debug("close: already closed");
      return;
    }
    this._ws.close(code, reason);
  };
  ReconnectingWebSocket2.prototype.reconnect = function(code, reason) {
    this._shouldReconnect = true;
    this._closeCalled = false;
    this._retryCount = -1;
    if (!this._ws || this._ws.readyState === this.CLOSED) {
      this._connect();
    } else {
      this._disconnect(code, reason);
      this._connect();
    }
  };
  ReconnectingWebSocket2.prototype.send = function(data) {
    if (this._ws && this._ws.readyState === this.OPEN) {
      this._debug("send", data);
      this._ws.send(data);
    } else {
      var _a = this._options.maxEnqueuedMessages, maxEnqueuedMessages = _a === void 0 ? DEFAULT.maxEnqueuedMessages : _a;
      if (this._messageQueue.length < maxEnqueuedMessages) {
        this._debug("enqueue", data);
        this._messageQueue.push(data);
      }
    }
  };
  ReconnectingWebSocket2.prototype.addEventListener = function(type, listener) {
    if (this._listeners[type]) {
      this._listeners[type].push(listener);
    }
  };
  ReconnectingWebSocket2.prototype.dispatchEvent = function(event) {
    var e_1, _a;
    var listeners = this._listeners[event.type];
    if (listeners) {
      try {
        for (var listeners_1 = __values(listeners), listeners_1_1 = listeners_1.next(); !listeners_1_1.done; listeners_1_1 = listeners_1.next()) {
          var listener = listeners_1_1.value;
          this._callEventListener(event, listener);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (listeners_1_1 && !listeners_1_1.done && (_a = listeners_1.return))
            _a.call(listeners_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }
    return true;
  };
  ReconnectingWebSocket2.prototype.removeEventListener = function(type, listener) {
    if (this._listeners[type]) {
      this._listeners[type] = this._listeners[type].filter(function(l) {
        return l !== listener;
      });
    }
  };
  ReconnectingWebSocket2.prototype._debug = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (this._options.debug) {
      console.log.apply(console, __spread(["RWS>"], args));
    }
  };
  ReconnectingWebSocket2.prototype._getNextDelay = function() {
    var _a = this._options, _b = _a.reconnectionDelayGrowFactor, reconnectionDelayGrowFactor = _b === void 0 ? DEFAULT.reconnectionDelayGrowFactor : _b, _c = _a.minReconnectionDelay, minReconnectionDelay = _c === void 0 ? DEFAULT.minReconnectionDelay : _c, _d = _a.maxReconnectionDelay, maxReconnectionDelay = _d === void 0 ? DEFAULT.maxReconnectionDelay : _d;
    var delay = 0;
    if (this._retryCount > 0) {
      delay = minReconnectionDelay * Math.pow(reconnectionDelayGrowFactor, this._retryCount - 1);
      if (delay > maxReconnectionDelay) {
        delay = maxReconnectionDelay;
      }
    }
    this._debug("next delay", delay);
    return delay;
  };
  ReconnectingWebSocket2.prototype._wait = function() {
    var _this = this;
    return new Promise(function(resolve) {
      setTimeout(resolve, _this._getNextDelay());
    });
  };
  ReconnectingWebSocket2.prototype._getNextUrl = function(urlProvider) {
    if (typeof urlProvider === "string") {
      return Promise.resolve(urlProvider);
    }
    if (typeof urlProvider === "function") {
      var url = urlProvider();
      if (typeof url === "string") {
        return Promise.resolve(url);
      }
      if (!!url.then) {
        return url;
      }
    }
    throw Error("Invalid URL");
  };
  ReconnectingWebSocket2.prototype._connect = function() {
    var _this = this;
    if (this._connectLock || !this._shouldReconnect) {
      return;
    }
    this._connectLock = true;
    var _a = this._options, _b = _a.maxRetries, maxRetries = _b === void 0 ? DEFAULT.maxRetries : _b, _c = _a.connectionTimeout, connectionTimeout = _c === void 0 ? DEFAULT.connectionTimeout : _c, _d = _a.WebSocket, WebSocket2 = _d === void 0 ? getGlobalWebSocket() : _d;
    if (this._retryCount >= maxRetries) {
      this._debug("max retries reached", this._retryCount, ">=", maxRetries);
      return;
    }
    this._retryCount++;
    this._debug("connect", this._retryCount);
    this._removeListeners();
    if (!isWebSocket(WebSocket2)) {
      throw Error("No valid WebSocket class provided");
    }
    this._wait().then(function() {
      return _this._getNextUrl(_this._url);
    }).then(function(url) {
      if (_this._closeCalled) {
        return;
      }
      _this._debug("connect", { url, protocols: _this._protocols });
      _this._ws = _this._protocols ? new WebSocket2(url, _this._protocols) : new WebSocket2(url);
      _this._ws.binaryType = _this._binaryType;
      _this._connectLock = false;
      _this._addListeners();
      _this._connectTimeout = setTimeout(function() {
        return _this._handleTimeout();
      }, connectionTimeout);
    });
  };
  ReconnectingWebSocket2.prototype._handleTimeout = function() {
    this._debug("timeout event");
    this._handleError(new ErrorEvent(Error("TIMEOUT"), this));
  };
  ReconnectingWebSocket2.prototype._disconnect = function(code, reason) {
    if (code === void 0) {
      code = 1e3;
    }
    this._clearTimeouts();
    if (!this._ws) {
      return;
    }
    this._removeListeners();
    try {
      this._ws.close(code, reason);
      this._handleClose(new CloseEvent(code, reason, this));
    } catch (error) {
    }
  };
  ReconnectingWebSocket2.prototype._acceptOpen = function() {
    this._debug("accept open");
    this._retryCount = 0;
  };
  ReconnectingWebSocket2.prototype._callEventListener = function(event, listener) {
    if ("handleEvent" in listener) {
      listener.handleEvent(event);
    } else {
      listener(event);
    }
  };
  ReconnectingWebSocket2.prototype._removeListeners = function() {
    if (!this._ws) {
      return;
    }
    this._debug("removeListeners");
    this._ws.removeEventListener("open", this._handleOpen);
    this._ws.removeEventListener("close", this._handleClose);
    this._ws.removeEventListener("message", this._handleMessage);
    this._ws.removeEventListener("error", this._handleError);
  };
  ReconnectingWebSocket2.prototype._addListeners = function() {
    if (!this._ws) {
      return;
    }
    this._debug("addListeners");
    this._ws.addEventListener("open", this._handleOpen);
    this._ws.addEventListener("close", this._handleClose);
    this._ws.addEventListener("message", this._handleMessage);
    this._ws.addEventListener("error", this._handleError);
  };
  ReconnectingWebSocket2.prototype._clearTimeouts = function() {
    clearTimeout(this._connectTimeout);
    clearTimeout(this._uptimeTimeout);
  };
  return ReconnectingWebSocket2;
}();
var reconnecting_websocket_mjs_default = ReconnectingWebSocket;

// node_modules/@mycelium-now/core/dist/core.esm.js
var import_wait_for_expect = __toESM(require_lib());
function _regeneratorRuntime() {
  _regeneratorRuntime = function() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = typeof Symbol == "function" ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
    return generator._invoke = function(innerFn2, self2, context2) {
      var state = "suspendedStart";
      return function(method, arg) {
        if (state === "executing")
          throw new Error("Generator is already running");
        if (state === "completed") {
          if (method === "throw")
            throw arg;
          return doneResult();
        }
        for (context2.method = method, context2.arg = arg; ; ) {
          var delegate = context2.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context2);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel)
                continue;
              return delegateResult;
            }
          }
          if (context2.method === "next")
            context2.sent = context2._sent = context2.arg;
          else if (context2.method === "throw") {
            if (state === "suspendedStart")
              throw state = "completed", context2.arg;
            context2.dispatchException(context2.arg);
          } else
            context2.method === "return" && context2.abrupt("return", context2.arg);
          state = "executing";
          var record = tryCatch(innerFn2, self2, context2);
          if (record.type === "normal") {
            if (state = context2.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
              continue;
            return {
              value: record.arg,
              done: context2.done
            };
          }
          record.type === "throw" && (state = "completed", context2.method = "throw", context2.arg = record.arg);
        }
      };
    }(innerFn, self, context), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type !== "throw") {
        var result = record.arg, value = result.value;
        return value && typeof value == "object" && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
          invoke("next", value2, resolve, reject);
        }, function(err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function(unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function(error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    this._invoke = function(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }
      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === void 0) {
      if (context.delegate = null, context.method === "throw") {
        if (delegate.iterator.return && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), context.method === "throw"))
          return ContinueSentinel;
        context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }
      return ContinueSentinel;
    }
    var record = tryCatch(method, delegate.iterator, context.arg);
    if (record.type === "throw")
      return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, context.method !== "return" && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if (typeof iterable.next == "function")
        return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1, next = function next2() {
          for (; ++i < iterable.length; )
            if (hasOwn.call(iterable, i))
              return next2.value = iterable[i], next2.done = false, next2;
          return next2.value = void 0, next2.done = true, next2;
        };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun == "function" && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction");
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    PromiseImpl === void 0 && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
    return this;
  }), define(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(object) {
    var keys = [];
    for (var key in object)
      keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length; ) {
        var key2 = keys.pop();
        if (key2 in object)
          return next.value = key2, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this)
          name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
    },
    stop: function() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if (rootRecord.type === "throw")
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function(exception) {
      if (this.done)
        throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if (entry.tryLoc === "root")
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function(record, afterLoc) {
      if (record.type === "throw")
        throw record.arg;
      return record.type === "break" || record.type === "continue" ? this.next = record.arg : record.type === "return" ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : record.type === "normal" && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName,
        nextLoc
      }, this.method === "next" && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var MessageTypes;
(function(MessageTypes2) {
  MessageTypes2["Hello"] = "hello";
  MessageTypes2["Error"] = "error";
  MessageTypes2["Subscribe"] = "subscribe";
  MessageTypes2["SubscribeSucess"] = "subscribe_success";
  MessageTypes2["Unsubscribe"] = "unsubscribe";
  MessageTypes2["UnsubscribeSuccess"] = "unsubscribe_success";
  MessageTypes2["Publish"] = "publish";
  MessageTypes2["PublishSuccess"] = "publish_success";
})(MessageTypes || (MessageTypes = {}));
var AuthenticationType;
(function(AuthenticationType2) {
  AuthenticationType2[AuthenticationType2["KEY"] = 0] = "KEY";
  AuthenticationType2[AuthenticationType2["TOKEN"] = 1] = "TOKEN";
})(AuthenticationType || (AuthenticationType = {}));
var defaults = {
  baseURL: "wss://mycelium-server.fly.dev/realtime"
};
var Client = function() {
  function Client2(connection) {
    this.channels = /* @__PURE__ */ new Map();
    this.seqNumber = 1;
    this.acks = /* @__PURE__ */ new Map();
    this.specialEventsHandlers = /* @__PURE__ */ new Map();
    this.ws = void 0;
    this.sid = void 0;
    this.isConnected = false;
    if (!connection.manual) {
      this.connect(connection);
    }
  }
  var _proto = Client2.prototype;
  _proto.getChannels = function getChannels() {
    return Array.from(this.channels.keys());
  };
  _proto.channel = function() {
    var _channel = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(channelName) {
      var _this = this;
      var existingChannel, subscribeSeq, ack, channel2;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!(!this.isConnected || !this.ws)) {
                _context3.next = 2;
                break;
              }
              throw new Error("failed to use channel " + channelName + ", not connected");
            case 2:
              existingChannel = this.channels.get(channelName);
              if (!existingChannel) {
                _context3.next = 5;
                break;
              }
              return _context3.abrupt("return", existingChannel.instance);
            case 5:
              subscribeSeq = this.seqNumber++;
              this.ws.send(JSON.stringify({
                t: MessageTypes.Subscribe,
                d: {
                  s: subscribeSeq,
                  c: channelName
                }
              }));
              _context3.next = 9;
              return (0, import_wait_for_expect.default)(function() {
                if (!_this.acks.has(subscribeSeq)) {
                  throw new Error("failed to subscribe to channel " + channelName + ", timed out");
                }
              });
            case 9:
              ack = this.acks.get(subscribeSeq);
              if (!(ack != null && ack.failureReason)) {
                _context3.next = 12;
                break;
              }
              throw new Error(ack.failureReason);
            case 12:
              channel2 = {
                name: channelName,
                unsubscribe: function() {
                  var _unsubscribe = _asyncToGenerator(_regeneratorRuntime().mark(function _callee() {
                    var unsubscribeSeq, ack2;
                    return _regeneratorRuntime().wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            if (!(!_this.isConnected || !_this.ws)) {
                              _context.next = 2;
                              break;
                            }
                            throw new Error("failed to unsubscribe from channel " + channelName + ", not connected");
                          case 2:
                            if (_this.channels.has(channelName)) {
                              _context.next = 4;
                              break;
                            }
                            throw new Error("failed to unsubscribe from channel " + channelName + ", not subscribed");
                          case 4:
                            unsubscribeSeq = _this.seqNumber++;
                            _this.ws.send(JSON.stringify({
                              t: MessageTypes.Unsubscribe,
                              d: {
                                s: unsubscribeSeq,
                                c: channelName
                              }
                            }));
                            _context.next = 8;
                            return (0, import_wait_for_expect.default)(function() {
                              if (!_this.acks.has(unsubscribeSeq)) {
                                throw new Error("failed to unsubscribe from channel " + channelName + ", timed out");
                              }
                            });
                          case 8:
                            ack2 = _this.acks.get(unsubscribeSeq);
                            if (!(ack2 != null && ack2.failureReason)) {
                              _context.next = 11;
                              break;
                            }
                            throw new Error(ack2.failureReason);
                          case 11:
                            _this.channels["delete"](channelName);
                          case 12:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }));
                  function unsubscribe() {
                    return _unsubscribe.apply(this, arguments);
                  }
                  return unsubscribe;
                }(),
                off: function off(event, listener) {
                  var channel3 = _this.channels.get(channelName);
                  if (channel3) {
                    _this.channels.set(channelName, _extends({}, channel3, {
                      eventListeners: channel3.eventListeners.filter(function(l) {
                        return l.event !== event && l.listener !== listener;
                      })
                    }));
                  }
                },
                offOnce: function offOnce(event, listener) {
                  var channel3 = _this.channels.get(channelName);
                  if (channel3) {
                    _this.channels.set(channelName, _extends({}, channel3, {
                      onceListeners: channel3.onceListeners.filter(function(l) {
                        return l.event !== event && l.listener !== listener;
                      })
                    }));
                  }
                },
                offAny: function offAny() {
                  for (var _len = arguments.length, listeners = new Array(_len), _key = 0; _key < _len; _key++) {
                    listeners[_key] = arguments[_key];
                  }
                  var channel3 = _this.channels.get(channelName);
                  if (channel3) {
                    if (!listeners.length) {
                      _this.channels.set(channelName, _extends({}, channel3, {
                        anyListeners: []
                      }));
                      return;
                    }
                    _this.channels.set(channelName, _extends({}, channel3, {
                      anyListeners: channel3.anyListeners.filter(function(l) {
                        return !listeners.some(function(listener) {
                          return listener === l;
                        });
                      })
                    }));
                  }
                },
                on: function on(event, _listener) {
                  var channel3 = _this.channels.get(channelName);
                  if (channel3) {
                    _this.channels.set(channelName, _extends({}, channel3, {
                      eventListeners: [].concat(channel3.eventListeners, [{
                        event,
                        listener: function listener(data, event2) {
                          _listener(data, event2);
                        }
                      }])
                    }));
                  }
                },
                onAny: function onAny(listener) {
                  var channel3 = _this.channels.get(channelName);
                  if (channel3) {
                    _this.channels.set(channelName, _extends({}, channel3, {
                      anyListeners: [].concat(channel3.anyListeners, [listener])
                    }));
                  }
                },
                once: function once(event, _listener2) {
                  var channel3 = _this.channels.get(channelName);
                  if (channel3) {
                    _this.channels.set(channelName, _extends({}, channel3, {
                      onceListeners: [].concat(channel3.onceListeners.filter(function(l) {
                        return l.event !== event;
                      }), [{
                        event,
                        listener: function listener(data, event2) {
                          _listener2(data, event2);
                        }
                      }])
                    }));
                  }
                },
                prependAny: function prependAny(listener) {
                  var channel3 = _this.channels.get(channelName);
                  if (channel3) {
                    _this.channels.set(channelName, _extends({}, channel3, {
                      anyListeners: [listener].concat(channel3.anyListeners)
                    }));
                  }
                },
                removeAllListeners: function removeAllListeners() {
                  for (var _len2 = arguments.length, events = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                    events[_key2] = arguments[_key2];
                  }
                  var channel3 = _this.channels.get(channelName);
                  if (channel3) {
                    if (!events.length) {
                      _this.channels.set(channelName, _extends({}, channel3, {
                        eventListeners: []
                      }));
                      return;
                    }
                    _this.channels.set(channelName, _extends({}, channel3, {
                      eventListeners: channel3.eventListeners.filter(function(l) {
                        return !events.some(function(ev) {
                          return ev === l.event;
                        });
                      })
                    }));
                  }
                },
                publish: function() {
                  var _publish = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(event, data, includePublisher) {
                    var publishSeq, ack2;
                    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            if (includePublisher === void 0) {
                              includePublisher = false;
                            }
                            if (!(!_this.isConnected || !_this.ws)) {
                              _context2.next = 3;
                              break;
                            }
                            throw new Error("failed to publish message on channel " + channelName + ", not connected");
                          case 3:
                            publishSeq = _this.seqNumber++;
                            _this.ws.send(JSON.stringify({
                              t: MessageTypes.Publish,
                              d: {
                                e: event,
                                s: publishSeq,
                                c: channelName,
                                d: data,
                                ip: includePublisher
                              }
                            }));
                            _context2.next = 7;
                            return (0, import_wait_for_expect.default)(function() {
                              if (!_this.acks.has(publishSeq)) {
                                throw new Error("failed to publish message on channel " + channelName + ", timed out");
                              }
                            });
                          case 7:
                            ack2 = _this.acks.get(publishSeq);
                            if (!(ack2 != null && ack2.failureReason)) {
                              _context2.next = 10;
                              break;
                            }
                            throw new Error(ack2.failureReason);
                          case 10:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }));
                  function publish(_x2, _x3, _x4) {
                    return _publish.apply(this, arguments);
                  }
                  return publish;
                }()
              };
              this.channels.set(channelName, {
                instance: channel2,
                anyListeners: [],
                eventListeners: [],
                onceListeners: []
              });
              return _context3.abrupt("return", channel2);
            case 15:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));
    function channel(_x) {
      return _channel.apply(this, arguments);
    }
    return channel;
  }();
  _proto.on = function on(specialEvent, handler) {
    var existingHandlers = this.specialEventsHandlers.get(specialEvent) || [];
    this.specialEventsHandlers.set(specialEvent, [].concat(existingHandlers, [handler]));
  };
  _proto.runSpecialEventHandlers = function runSpecialEventHandlers(specialEvent) {
    var _this$specialEventsHa;
    (_this$specialEventsHa = this.specialEventsHandlers.get(specialEvent)) == null ? void 0 : _this$specialEventsHa.forEach(function(handler) {
      handler();
    });
  };
  _proto.disconnect = function disconnect() {
    if (!this.ws || !this.isConnected) {
      throw new Error("can't disconnect, not connected");
    }
    this.ws.close();
    this.acks = /* @__PURE__ */ new Map();
    this.channels = /* @__PURE__ */ new Map();
    this.seqNumber = 1;
    this.isConnected = false;
    this.sid = void 0;
    this.ws = void 0;
  };
  _proto.connect = function() {
    var _connect = _asyncToGenerator(_regeneratorRuntime().mark(function _callee4(_ref) {
      var authentication, _ref$baseURL, baseURL, url, key, token;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              authentication = _ref.authentication, _ref$baseURL = _ref.baseURL, baseURL = _ref$baseURL === void 0 ? defaults.baseURL : _ref$baseURL;
              if (!(authentication.type === AuthenticationType.KEY)) {
                _context4.next = 8;
                break;
              }
              _context4.next = 4;
              return authentication.getKey();
            case 4:
              key = _context4.sent;
              url = baseURL + "?key=" + key;
              _context4.next = 12;
              break;
            case 8:
              _context4.next = 10;
              return authentication.getToken();
            case 10:
              token = _context4.sent;
              url = baseURL + "?token=" + token;
            case 12:
              this.ws = new reconnecting_websocket_mjs_default(url);
              this.setupListeners();
            case 14:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));
    function connect(_x5) {
      return _connect.apply(this, arguments);
    }
    return connect;
  }();
  _proto.setupListeners = function setupListeners() {
    var _this2 = this;
    if (!this.ws) {
      return;
    }
    this.ws.addEventListener("error", function() {
      _this2.runSpecialEventHandlers("disconnect");
    });
    this.ws.addEventListener("close", function() {
      _this2.runSpecialEventHandlers("disconnect");
    });
    this.ws.addEventListener("message", function(ev) {
      try {
        var message = JSON.parse(ev.data.toString());
        switch (message.t) {
          case MessageTypes.Hello: {
            var sid = message.d.sid;
            _this2.sid = sid;
            _this2.isConnected = true;
            _this2.runSpecialEventHandlers("connect");
            return;
          }
          case MessageTypes.Publish: {
            var _message$d = message.d, channelName = _message$d.c, data = _message$d.d, event = _message$d.e;
            var channel = _this2.channels.get(channelName);
            if (channel) {
              var _channel$onceListener;
              channel.eventListeners.forEach(function(l) {
                if (l.event === event) {
                  l.listener(data, event);
                }
              });
              (_channel$onceListener = channel.onceListeners.find(function(l) {
                return l.event === event;
              })) == null ? void 0 : _channel$onceListener.listener(data, event);
              channel.anyListeners.forEach(function(listener) {
                listener(data, event);
              });
            }
            return;
          }
          case MessageTypes.UnsubscribeSuccess:
          case MessageTypes.PublishSuccess:
          case MessageTypes.SubscribeSucess: {
            var _message$d2 = message.d, _channelName = _message$d2.c, s = _message$d2.s;
            _this2.acks.set(s, {});
            return;
          }
          case MessageTypes.Error: {
            var reason = message.r, _s = message.s;
            if (_s) {
              _this2.acks.set(_s, {
                failureReason: reason
              });
            }
            return;
          }
        }
      } catch (error) {
        console.error(error);
      }
    });
  };
  return Client2;
}();

// node_modules/use-deep-compare-effect/dist/use-deep-compare-effect.esm.js
var React = __toESM(require_react());

// node_modules/dequal/dist/index.mjs
var has = Object.prototype.hasOwnProperty;
function find(iter, tar, key) {
  for (key of iter.keys()) {
    if (dequal(key, tar))
      return key;
  }
}
function dequal(foo, bar) {
  var ctor, len, tmp;
  if (foo === bar)
    return true;
  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date)
      return foo.getTime() === bar.getTime();
    if (ctor === RegExp)
      return foo.toString() === bar.toString();
    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && dequal(foo[len], bar[len]))
          ;
      }
      return len === -1;
    }
    if (ctor === Set) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len;
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp)
            return false;
        }
        if (!bar.has(tmp))
          return false;
      }
      return true;
    }
    if (ctor === Map) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len[0];
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp)
            return false;
        }
        if (!dequal(len[1], bar.get(tmp))) {
          return false;
        }
      }
      return true;
    }
    if (ctor === ArrayBuffer) {
      foo = new Uint8Array(foo);
      bar = new Uint8Array(bar);
    } else if (ctor === DataView) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo.getInt8(len) === bar.getInt8(len))
          ;
      }
      return len === -1;
    }
    if (ArrayBuffer.isView(foo)) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo[len] === bar[len])
          ;
      }
      return len === -1;
    }
    if (!ctor || typeof foo === "object") {
      len = 0;
      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor))
          return false;
        if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor]))
          return false;
      }
      return Object.keys(bar).length === len;
    }
  }
  return foo !== foo && bar !== bar;
}

// node_modules/use-deep-compare-effect/dist/use-deep-compare-effect.esm.js
function checkDeps(deps) {
  if (!deps || !deps.length) {
    throw new Error("useDeepCompareEffect should not be used with no dependencies. Use React.useEffect instead.");
  }
  if (deps.every(isPrimitive)) {
    throw new Error("useDeepCompareEffect should not be used with dependencies that are all primitive values. Use React.useEffect instead.");
  }
}
function isPrimitive(val) {
  return val == null || /^[sbn]/.test(typeof val);
}
function useDeepCompareMemoize(value) {
  var ref = React.useRef(value);
  var signalRef = React.useRef(0);
  if (!dequal(value, ref.current)) {
    ref.current = value;
    signalRef.current += 1;
  }
  return React.useMemo(function() {
    return ref.current;
  }, [signalRef.current]);
}
function useDeepCompareEffect(callback, dependencies) {
  if (true) {
    checkDeps(dependencies);
  }
  return React.useEffect(callback, useDeepCompareMemoize(dependencies));
}

// node_modules/@mycelium-now/react/dist/react.esm.js
function _regeneratorRuntime2() {
  _regeneratorRuntime2 = function() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = typeof Symbol == "function" ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
    return generator._invoke = function(innerFn2, self2, context2) {
      var state = "suspendedStart";
      return function(method, arg) {
        if (state === "executing")
          throw new Error("Generator is already running");
        if (state === "completed") {
          if (method === "throw")
            throw arg;
          return doneResult();
        }
        for (context2.method = method, context2.arg = arg; ; ) {
          var delegate = context2.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context2);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel)
                continue;
              return delegateResult;
            }
          }
          if (context2.method === "next")
            context2.sent = context2._sent = context2.arg;
          else if (context2.method === "throw") {
            if (state === "suspendedStart")
              throw state = "completed", context2.arg;
            context2.dispatchException(context2.arg);
          } else
            context2.method === "return" && context2.abrupt("return", context2.arg);
          state = "executing";
          var record = tryCatch(innerFn2, self2, context2);
          if (record.type === "normal") {
            if (state = context2.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
              continue;
            return {
              value: record.arg,
              done: context2.done
            };
          }
          record.type === "throw" && (state = "completed", context2.method = "throw", context2.arg = record.arg);
        }
      };
    }(innerFn, self, context), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type !== "throw") {
        var result = record.arg, value = result.value;
        return value && typeof value == "object" && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
          invoke("next", value2, resolve, reject);
        }, function(err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function(unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function(error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    this._invoke = function(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }
      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === void 0) {
      if (context.delegate = null, context.method === "throw") {
        if (delegate.iterator.return && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), context.method === "throw"))
          return ContinueSentinel;
        context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }
      return ContinueSentinel;
    }
    var record = tryCatch(method, delegate.iterator, context.arg);
    if (record.type === "throw")
      return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, context.method !== "return" && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if (typeof iterable.next == "function")
        return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1, next = function next2() {
          for (; ++i < iterable.length; )
            if (hasOwn.call(iterable, i))
              return next2.value = iterable[i], next2.done = false, next2;
          return next2.value = void 0, next2.done = true, next2;
        };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun == "function" && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction");
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    PromiseImpl === void 0 && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
    return this;
  }), define(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(object) {
    var keys = [];
    for (var key in object)
      keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length; ) {
        var key2 = keys.pop();
        if (key2 in object)
          return next.value = key2, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this)
          name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
    },
    stop: function() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if (rootRecord.type === "throw")
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function(exception) {
      if (this.done)
        throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if (entry.tryLoc === "root")
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function(record, afterLoc) {
      if (record.type === "throw")
        throw record.arg;
      return record.type === "break" || record.type === "continue" ? this.next = record.arg : record.type === "return" ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : record.type === "normal" && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName,
        nextLoc
      }, this.method === "next" && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator2(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
var MyceliumContext = (0, import_react.createContext)(null);
function MyceliumProvider(_ref) {
  var authentication = _ref.authentication, baseURL = _ref.baseURL, children = _ref.children;
  var _useState = (0, import_react.useState)({
    isConnecting: false,
    isConnected: false,
    isError: false,
    error: null,
    client: null
  }), state = _useState[0], setState = _useState[1];
  useDeepCompareEffect(function() {
    function _connect() {
      return _connect2.apply(this, arguments);
    }
    function _connect2() {
      _connect2 = _asyncToGenerator2(_regeneratorRuntime2().mark(function _callee() {
        var client;
        return _regeneratorRuntime2().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                setState({
                  isConnecting: true,
                  isConnected: false,
                  isError: false,
                  error: null,
                  client: null
                });
                client = new Client({
                  authentication,
                  baseURL,
                  manual: true
                });
                _context.next = 5;
                return client.connect({
                  authentication,
                  baseURL
                });
              case 5:
                setState({
                  isConnecting: false,
                  isConnected: true,
                  isError: false,
                  error: null,
                  client
                });
                _context.next = 11;
                break;
              case 8:
                _context.prev = 8;
                _context.t0 = _context["catch"](0);
                setState({
                  isConnecting: false,
                  isConnected: true,
                  isError: true,
                  error: _context.t0,
                  client: null
                });
              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[0, 8]]);
      }));
      return _connect2.apply(this, arguments);
    }
    _connect();
    return function() {
      var _state$client;
      (_state$client = state.client) == null ? void 0 : _state$client.disconnect();
    };
  }, [authentication, baseURL]);
  return import_react.default.createElement(MyceliumContext.Provider, {
    value: state
  }, children);
}
var NOT_IN_CONTEXT_WARNING = "No Mycelium context. Did you forget to wrap your app in a <MyceliumProvider />?";
function useMyceliumClient() {
  var ctx = (0, import_react.useContext)(MyceliumContext);
  if (ctx == null) {
    throw new Error(NOT_IN_CONTEXT_WARNING);
  }
  return ctx;
}
function useChannel(channelName) {
  !channelName ? true ? (0, import_invariant.default)(false, "Must supply channelName to useChannel") : (0, import_invariant.default)(false) : void 0;
  var _useMyceliumClient = useMyceliumClient(), client = _useMyceliumClient.client, isConnected = _useMyceliumClient.isConnected;
  var _useState = (0, import_react.useState)(), channel = _useState[0], setChannel = _useState[1];
  var _useState2 = (0, import_react.useState)({
    isLoading: false,
    isSuccess: false,
    isError: false,
    error: null
  }), state = _useState2[0], setState = _useState2[1];
  (0, import_react.useEffect)(function() {
    function _subscribe() {
      return _subscribe2.apply(this, arguments);
    }
    function _subscribe2() {
      _subscribe2 = _asyncToGenerator2(_regeneratorRuntime2().mark(function _callee() {
        return _regeneratorRuntime2().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(!client || !isConnected)) {
                  _context.next = 2;
                  break;
                }
                return _context.abrupt("return");
              case 2:
                _context.prev = 2;
                setState({
                  isLoading: true,
                  isSuccess: false,
                  isError: false,
                  error: null
                });
                _context.t0 = setChannel;
                _context.next = 7;
                return client.channel(channelName);
              case 7:
                _context.t1 = _context.sent;
                (0, _context.t0)(_context.t1);
                setState({
                  isLoading: false,
                  isSuccess: true,
                  isError: false,
                  error: null
                });
                _context.next = 15;
                break;
              case 12:
                _context.prev = 12;
                _context.t2 = _context["catch"](2);
                setState({
                  isLoading: false,
                  isSuccess: false,
                  isError: true,
                  error: _context.t2
                });
              case 15:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[2, 12]]);
      }));
      return _subscribe2.apply(this, arguments);
    }
    _subscribe();
    return function() {
      channel == null ? void 0 : channel.unsubscribe()["catch"](console.error);
    };
  }, [client]);
  return {
    channel,
    isLoading: state.isLoading,
    isSuccess: state.isSuccess,
    isError: state.isError,
    error: state.error
  };
}
function usePublishEvent(channel) {
  var _useState = (0, import_react.useState)({
    isLoading: false,
    isSuccess: false,
    isError: false,
    error: null
  }), state = _useState[0], setState = _useState[1];
  return {
    publish: function() {
      var _publish = _asyncToGenerator2(_regeneratorRuntime2().mark(function _callee(event, data, includePublisher) {
        return _regeneratorRuntime2().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (includePublisher === void 0) {
                  includePublisher = false;
                }
                if (channel) {
                  _context.next = 3;
                  break;
                }
                return _context.abrupt("return");
              case 3:
                _context.prev = 3;
                setState({
                  isLoading: true,
                  isSuccess: false,
                  isError: false,
                  error: null
                });
                _context.next = 7;
                return channel.publish(event, data, includePublisher);
              case 7:
                setState({
                  isLoading: false,
                  isSuccess: true,
                  isError: false,
                  error: null
                });
                _context.next = 13;
                break;
              case 10:
                _context.prev = 10;
                _context.t0 = _context["catch"](3);
                setState({
                  isLoading: false,
                  isSuccess: false,
                  isError: true,
                  error: _context.t0
                });
              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[3, 10]]);
      }));
      function publish(_x, _x2, _x3) {
        return _publish.apply(this, arguments);
      }
      return publish;
    }(),
    isLoading: state.isLoading,
    isSuccess: state.isSuccess,
    isError: state.isError,
    error: state.error
  };
}
function useSubscribe() {
  var _useMyceliumClient = useMyceliumClient(), client = _useMyceliumClient.client;
  var _useState = (0, import_react.useState)(), channel = _useState[0], setChannel = _useState[1];
  var _useState2 = (0, import_react.useState)({
    isLoading: false,
    isSuccess: false,
    isError: false,
    error: null
  }), state = _useState2[0], setState = _useState2[1];
  (0, import_react.useEffect)(function() {
    return function() {
      channel == null ? void 0 : channel.unsubscribe()["catch"](console.error);
    };
  }, [client]);
  return {
    subscribe: function() {
      var _subscribe = _asyncToGenerator2(_regeneratorRuntime2().mark(function _callee(channelName) {
        return _regeneratorRuntime2().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (client) {
                  _context.next = 2;
                  break;
                }
                return _context.abrupt("return");
              case 2:
                _context.prev = 2;
                setState({
                  isLoading: true,
                  isSuccess: false,
                  isError: false,
                  error: null
                });
                _context.t0 = setChannel;
                _context.next = 7;
                return client.channel(channelName);
              case 7:
                _context.t1 = _context.sent;
                (0, _context.t0)(_context.t1);
                setState({
                  isLoading: false,
                  isSuccess: true,
                  isError: false,
                  error: null
                });
                _context.next = 15;
                break;
              case 12:
                _context.prev = 12;
                _context.t2 = _context["catch"](2);
                setState({
                  isLoading: false,
                  isSuccess: false,
                  isError: true,
                  error: _context.t2
                });
              case 15:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[2, 12]]);
      }));
      function subscribe(_x) {
        return _subscribe.apply(this, arguments);
      }
      return subscribe;
    }(),
    isLoading: state.isLoading,
    isSuccess: state.isSuccess,
    isError: state.isError,
    error: state.error
  };
}
function useOnEvent(channel, event, listener) {
  !event ? true ? (0, import_invariant.default)(false, "Must supply event to useOnEvent") : (0, import_invariant.default)(false) : void 0;
  !listener ? true ? (0, import_invariant.default)(false, "Must supply listener to useOnEvent") : (0, import_invariant.default)(false) : void 0;
  (0, import_react.useEffect)(function() {
    if (!channel) {
      return;
    }
    channel.on(event, listener);
    return function() {
      channel.off(event, listener);
    };
  }, [channel, event, listener]);
}
function useOnAnyEvent(channel, listener) {
  !listener ? true ? (0, import_invariant.default)(false, "Must supply listener to useOnAnyEvent") : (0, import_invariant.default)(false) : void 0;
  (0, import_react.useEffect)(function() {
    if (!channel) {
      return;
    }
    channel.onAny(listener);
    return function() {
      channel.offAny(listener);
    };
  }, [channel, listener]);
}
function useOnceEvent(channel, event, listener) {
  !event ? true ? (0, import_invariant.default)(false, "Must supply event to useOnceEvent") : (0, import_invariant.default)(false) : void 0;
  !listener ? true ? (0, import_invariant.default)(false, "Must supply listener to useOnceEvent") : (0, import_invariant.default)(false) : void 0;
  (0, import_react.useEffect)(function() {
    if (!channel) {
      return;
    }
    channel.once(event, listener);
    return function() {
      channel.offOnce(event, listener);
    };
  }, [channel, event, listener]);
}
function usePrependAnyEvent(channel, listener) {
  !listener ? true ? (0, import_invariant.default)(false, "Must supply listener to usePrependAnyEvent") : (0, import_invariant.default)(false) : void 0;
  (0, import_react.useEffect)(function() {
    if (!channel) {
      return;
    }
    channel.prependAny(listener);
    return function() {
      channel.offAny(listener);
    };
  }, [channel, listener]);
}
export {
  AuthenticationType,
  Client,
  MyceliumProvider,
  useChannel,
  useMyceliumClient,
  useOnAnyEvent,
  useOnEvent,
  useOnceEvent,
  usePrependAnyEvent,
  usePublishEvent,
  useSubscribe
};
/*!
 * Reconnecting WebSocket
 * by Pedro Ladaria <pedro.ladaria@gmail.com>
 * https://github.com/pladaria/reconnecting-websocket
 * License MIT
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
//# sourceMappingURL=@mycelium-now_react.js.map
